#pragma once

#include "game/minigame.hpp"
#include "game/exploit-sequencer/exploit-sequencer-states.hpp"
#include <cstdlib>
#include <vector>
#include <cstdint>

constexpr int EXPLOIT_SEQUENCER_APP_ID = 7;

enum class ExploitNoteType : uint8_t {
    PRESS = 0,
    HOLD = 1
};

enum class ExploitLane : uint8_t {
    UP = 0,
    DOWN = 1
};

enum class ExploitNoteGrade : uint8_t {
    NONE = 0,
    MISS = 1,
    GOOD = 2,
    PERFECT = 3
};

struct ExploitNote {
    ExploitNoteType type = ExploitNoteType::PRESS;
    ExploitLane lane = ExploitLane::UP;
    int xPosition = 128;          // start position (offscreen right)
    int holdLength = 0;           // length in pixels (for HOLD notes)
    ExploitNoteGrade grade = ExploitNoteGrade::NONE;
    bool active = true;           // still needs to be processed
};

struct ExploitSequencerConfig {
    // Rhythm game parameters
    int rounds = 4;
    int notesPerRound = 8;
    float dualLaneChance = 0.0f;      // probability of dual-lane notes
    float holdNoteChance = 0.15f;     // probability of hold notes
    int noteSpeedMs = 50;             // ms per pixel movement
    float speedRampPerRound = 1.0f;   // speed multiplier per round
    int holdDurationMs = 800;         // hold note duration
    int hitZoneWidthPx = 20;          // hit zone width
    int perfectZonePx = 6;            // perfect zone width (centered in hit zone)
    int lives = 3;                    // lives before losing

    // Display layout constants
    static constexpr int HIT_ZONE_X = 8;
    static constexpr int UP_LANE_Y = 10;
    static constexpr int UP_LANE_HEIGHT = 20;
    static constexpr int DIVIDER_Y = 31;
    static constexpr int DOWN_LANE_Y = 33;
    static constexpr int DOWN_LANE_HEIGHT = 20;

    unsigned long rngSeed = 0;        // 0 = random, nonzero = deterministic
    bool managedMode = false;
};

struct ExploitSequencerSession {
    // Round tracking
    int currentRound = 0;
    int score = 0;
    int livesRemaining = 3;

    // Pattern and note tracking
    std::vector<ExploitNote> currentPattern;
    int currentNoteIndex = 0;

    // Input tracking
    bool upPressed = false;
    bool downPressed = false;

    // Hold state tracking
    bool upHoldActive = false;
    bool downHoldActive = false;
    int upHoldNoteIndex = -1;
    int downHoldNoteIndex = -1;

    // Statistics
    int perfectCount = 0;
    int goodCount = 0;
    int missCount = 0;

    void reset() {
        currentRound = 0;
        score = 0;
        livesRemaining = 3;
        currentPattern.clear();
        currentNoteIndex = 0;
        upPressed = false;
        downPressed = false;
        upHoldActive = false;
        downHoldActive = false;
        upHoldNoteIndex = -1;
        downHoldNoteIndex = -1;
        perfectCount = 0;
        goodCount = 0;
        missCount = 0;
    }
};

inline ExploitSequencerConfig makeExploitSequencerEasyConfig() {
    ExploitSequencerConfig c;
    c.rounds = 4;
    c.notesPerRound = 8;
    c.dualLaneChance = 0.0f;      // no dual-lane notes in easy mode
    c.holdNoteChance = 0.15f;
    c.noteSpeedMs = 50;
    c.speedRampPerRound = 1.0f;   // no speed increase
    c.holdDurationMs = 800;
    c.hitZoneWidthPx = 20;
    c.perfectZonePx = 6;
    c.lives = 3;
    return c;
}

inline ExploitSequencerConfig makeExploitSequencerHardConfig() {
    ExploitSequencerConfig c;
    c.rounds = 4;
    c.notesPerRound = 12;
    c.dualLaneChance = 0.4f;      // 40% chance of dual-lane notes
    c.holdNoteChance = 0.35f;
    c.noteSpeedMs = 30;
    c.speedRampPerRound = 1.1f;   // 10% speed increase per round
    c.holdDurationMs = 500;
    c.hitZoneWidthPx = 14;
    c.perfectZonePx = 3;
    c.lives = 3;
    return c;
}

const ExploitSequencerConfig EXPLOIT_SEQUENCER_EASY = makeExploitSequencerEasyConfig();
const ExploitSequencerConfig EXPLOIT_SEQUENCER_HARD = makeExploitSequencerHardConfig();

/*
 * Exploit Sequencer â€” Guitar Hero-style rhythm minigame.
 *
 * Notes scroll down two lanes (UP/DOWN). Player presses PRIMARY (UP) or
 * SECONDARY (DOWN) buttons to hit notes when they reach the hit zone.
 * Supports PRESS and HOLD note types. Multiple rounds with increasing
 * difficulty. Complete all rounds to win, lose all lives to lose.
 *
 * In managed mode (via FDN), terminal states call
 * Device::returnToPreviousApp(). In standalone mode, loops to intro.
 */
class ExploitSequencer : public MiniGame {
public:
    explicit ExploitSequencer(ExploitSequencerConfig config) :
        MiniGame(EXPLOIT_SEQUENCER_APP_ID, GameType::EXPLOIT_SEQUENCER, "EXPLOIT SEQUENCER"),
        config(config)
    {
    }

    void populateStateMap() override;
    void resetGame() override;

    ExploitSequencerConfig& getConfig() { return config; }
    ExploitSequencerSession& getSession() { return session; }

    // Pattern generation
    std::vector<ExploitNote> generatePattern(int round);

private:
    ExploitSequencerConfig config;
    ExploitSequencerSession session;
};
