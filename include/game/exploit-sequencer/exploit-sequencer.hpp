#pragma once

#include "game/minigame.hpp"
#include "game/exploit-sequencer/exploit-sequencer-states.hpp"

constexpr int EXPLOIT_SEQUENCER_APP_ID = 7;

struct ExploitSequencerConfig {
    int timeLimitMs = 0;
    unsigned long rngSeed = 0;
    bool managedMode = false;
};

struct ExploitSequencerSession {
    int score = 0;
    void reset() { score = 0; }
};

inline ExploitSequencerConfig makeExploitSequencerEasyConfig() {
    ExploitSequencerConfig c;
    c.timeLimitMs = 0;
    c.rngSeed = 0;
    c.managedMode = false;
    return c;
}

inline ExploitSequencerConfig makeExploitSequencerHardConfig() {
    ExploitSequencerConfig c;
    c.timeLimitMs = 0;
    c.rngSeed = 0;
    c.managedMode = false;
    return c;
}

const ExploitSequencerConfig EXPLOIT_SEQUENCER_EASY = makeExploitSequencerEasyConfig();
const ExploitSequencerConfig EXPLOIT_SEQUENCER_HARD = makeExploitSequencerHardConfig();

/*
 * Exploit Sequencer â€” stub minigame.
 *
 * Placeholder implementation: shows intro, auto-wins after 2s.
 * Phase 2 replaces with real exploit-chaining mechanics.
 *
 * In managed mode (via FDN), terminal states call
 * Device::returnToPreviousApp(). In standalone mode, loops to intro.
 */
class ExploitSequencer : public MiniGame {
public:
    explicit ExploitSequencer(ExploitSequencerConfig config) :
        MiniGame(EXPLOIT_SEQUENCER_APP_ID, GameType::EXPLOIT_SEQUENCER, "EXPLOIT SEQUENCER"),
        config(config)
    {
    }

    void populateStateMap() override;
    void resetGame() override;

    ExploitSequencerConfig& getConfig() { return config; }
    ExploitSequencerSession& getSession() { return session; }

private:
    ExploitSequencerConfig config;
    ExploitSequencerSession session;
};
