#pragma once

#ifdef NATIVE_BUILD

#include <gtest/gtest.h>
#include "cli/cli-device.hpp"
#include "cli/cli-serial-broker.hpp"
#include "game/exploit-sequencer/exploit-sequencer.hpp"
#include "game/exploit-sequencer/exploit-sequencer-states.hpp"
#include "game/minigame.hpp"
#include "device/device-types.hpp"
#include "utils/simple-timer.hpp"
#include <cstdint>

using namespace cli;

// ============================================
// EXPLOIT SEQUENCER TEST SUITE (standalone)
// ============================================

class ExploitSequencerTestSuite : public testing::Test {
public:
    void SetUp() override {
        device_ = DeviceFactory::createGameDevice(0, "exploit-sequencer");
        SimpleTimer::setPlatformClock(device_.clockDriver);
        game_ = static_cast<ExploitSequencer*>(device_.game);
    }

    void TearDown() override {
        DeviceFactory::destroyDevice(device_);
    }

    void tick(int n = 1) {
        for (int i = 0; i < n; i++) {
            device_.pdn->loop();
        }
    }

    void tickWithTime(int n, int delayMs) {
        for (int i = 0; i < n; i++) {
            device_.clockDriver->advance(delayMs);
            device_.pdn->loop();
        }
    }

    DeviceInstance device_;
    ExploitSequencer* game_ = nullptr;
};

// ============================================
// EXPLOIT SEQUENCER MANAGED TEST SUITE (FDN)
// ============================================

class ExploitSequencerManagedTestSuite : public testing::Test {
public:
    void SetUp() override {
        player_ = DeviceFactory::createDevice(0, true);
        SimpleTimer::setPlatformClock(player_.clockDriver);
    }

    void TearDown() override {
        DeviceFactory::destroyDevice(player_);
    }

    void tick(int n = 1) {
        for (int i = 0; i < n; i++) {
            player_.pdn->loop();
        }
    }

    void tickWithTime(int n, int delayMs) {
        for (int i = 0; i < n; i++) {
            player_.clockDriver->advance(delayMs);
            player_.pdn->loop();
        }
    }

    void advanceToIdle() {
        player_.game->skipToState(player_.pdn, 7);
        player_.pdn->loop();
    }

    int getPlayerStateId() {
        return player_.game->getCurrentState()->getStateId();
    }

    ExploitSequencer* getExploitSequencer() {
        return static_cast<ExploitSequencer*>(
            player_.pdn->getApp(StateId(EXPLOIT_SEQUENCER_APP_ID)));
    }

    DeviceInstance player_;
};

// ============================================
// CONFIG PRESET TESTS
// ============================================

/*
 * Test: EASY config has wide timing window, few exploits, generous fails.
 */
void exploitSeqEasyConfigPresets(ExploitSequencerTestSuite* suite) {
    ExploitSequencerConfig easy = makeExploitSequencerEasyConfig();
    ASSERT_EQ(easy.scrollSpeedMs, 40);
    ASSERT_EQ(easy.scrollLength, 100);
    ASSERT_EQ(easy.markerPosition, 50);
    ASSERT_EQ(easy.timingWindow, 15);
    ASSERT_EQ(easy.exploitsPerSeq, 2);
    ASSERT_EQ(easy.sequences, 2);
    ASSERT_EQ(easy.failsAllowed, 3);
}

/*
 * Test: HARD config has narrow timing window, more exploits, strict fails.
 */
void exploitSeqHardConfigPresets(ExploitSequencerTestSuite* suite) {
    ExploitSequencerConfig hard = makeExploitSequencerHardConfig();
    ASSERT_EQ(hard.scrollSpeedMs, 25);
    ASSERT_EQ(hard.scrollLength, 100);
    ASSERT_EQ(hard.markerPosition, 50);
    ASSERT_EQ(hard.timingWindow, 6);
    ASSERT_EQ(hard.exploitsPerSeq, 4);
    ASSERT_EQ(hard.sequences, 4);
    ASSERT_EQ(hard.failsAllowed, 1);
}

// ============================================
// INTRO TESTS
// ============================================

/*
 * Test: Intro resets a dirty session to clean state.
 */
void exploitSeqIntroResetsSession(ExploitSequencerTestSuite* suite) {
    // Dirty the session
    auto& session = suite->game_->getSession();
    session.score = 999;
    session.fails = 5;
    session.currentSequence = 3;
    session.currentExploit = 2;
    session.symbolPosition = 77;
    session.playerPressed = true;

    // Skip to Intro (index 0) to trigger reset
    suite->game_->skipToState(suite->device_.pdn, 0);
    suite->tick(1);

    ASSERT_EQ(session.score, 0);
    ASSERT_EQ(session.fails, 0);
    ASSERT_EQ(session.currentSequence, 0);
    ASSERT_EQ(session.currentExploit, 0);
    ASSERT_EQ(session.symbolPosition, 0);
    ASSERT_FALSE(session.playerPressed);
}

/*
 * Test: Intro transitions to Show after timer expires.
 */
void exploitSeqIntroTransitionsToShow(ExploitSequencerTestSuite* suite) {
    // Skip to intro to ensure clean state with clock set
    suite->game_->skipToState(suite->device_.pdn, 0);
    suite->tick(1);

    ASSERT_EQ(suite->game_->getCurrentState()->getStateId(), EXPLOIT_INTRO);

    // Advance past 2s intro timer
    suite->tickWithTime(30, 100);

    ASSERT_EQ(suite->game_->getCurrentState()->getStateId(), EXPLOIT_SHOW);
}

// ============================================
// SHOW TESTS
// ============================================

/*
 * Test: Show state has correct state ID.
 */
void exploitSeqShowDisplaysSequenceInfo(ExploitSequencerTestSuite* suite) {
    // Skip to Show (index 1)
    suite->game_->skipToState(suite->device_.pdn, 1);
    suite->tick(1);

    ASSERT_EQ(suite->game_->getCurrentState()->getStateId(), EXPLOIT_SHOW);
}

/*
 * Test: Show transitions to Gameplay after timer.
 */
void exploitSeqShowTransitionsToGameplay(ExploitSequencerTestSuite* suite) {
    suite->game_->skipToState(suite->device_.pdn, 1);
    suite->tick(1);

    ASSERT_EQ(suite->game_->getCurrentState()->getStateId(), EXPLOIT_SHOW);

    // Advance past 1.5s show timer
    suite->tickWithTime(20, 100);

    ASSERT_EQ(suite->game_->getCurrentState()->getStateId(), EXPLOIT_GAMEPLAY);
}

// ============================================
// GAMEPLAY TESTS
// ============================================

/*
 * Test: Symbol position advances with time during gameplay.
 */
void exploitSeqSymbolAdvancesWithTime(ExploitSequencerTestSuite* suite) {
    // Configure for predictable timing
    suite->game_->getConfig().scrollSpeedMs = 10;

    suite->game_->skipToState(suite->device_.pdn, 2);  // Gameplay
    suite->tick(1);

    int initialPos = suite->game_->getSession().symbolPosition;

    // Advance time — each tick at 15ms should exceed 10ms scroll speed
    suite->tickWithTime(5, 15);

    ASSERT_GT(suite->game_->getSession().symbolPosition, initialPos);
}

/*
 * Test: Correct timing (press within window) increases score.
 */
void exploitSeqCorrectTimingHit(ExploitSequencerTestSuite* suite) {
    suite->game_->getConfig().scrollSpeedMs = 10;
    suite->game_->getConfig().markerPosition = 50;
    suite->game_->getConfig().timingWindow = 45;  // Very wide for test

    suite->game_->skipToState(suite->device_.pdn, 2);  // Gameplay
    suite->tick(1);

    // Advance symbol into window
    suite->tickWithTime(10, 15);
    auto& session = suite->game_->getSession();
    ASSERT_GE(session.symbolPosition, 5);

    // Press button
    suite->device_.primaryButtonDriver->execCallback(ButtonInteraction::CLICK);
    suite->tick(3);

    // Should be in Evaluate or beyond — check score increased
    ASSERT_EQ(session.score, 100);
}

/*
 * Test: Wrong timing (press outside window) increases fails.
 */
void exploitSeqWrongTimingMiss(ExploitSequencerTestSuite* suite) {
    suite->game_->getConfig().scrollSpeedMs = 100;
    suite->game_->getConfig().markerPosition = 50;
    suite->game_->getConfig().timingWindow = 2;  // Very narrow

    suite->game_->skipToState(suite->device_.pdn, 2);  // Gameplay
    suite->tick(1);

    // Don't advance time much — symbol stays near 0 (far from marker=50)
    suite->tickWithTime(2, 50);

    auto& session = suite->game_->getSession();
    int failsBefore = session.fails;

    // Press button while symbol is far from marker
    suite->device_.primaryButtonDriver->execCallback(ButtonInteraction::CLICK);
    suite->tick(3);

    // Fails should increase
    ASSERT_GT(session.fails, failsBefore);
}

/*
 * Test: Timeout (symbol scrolls past end without press) counts as fail.
 */
void exploitSeqTimeoutCountsFail(ExploitSequencerTestSuite* suite) {
    // Use a very short scroll to make timeout quick
    suite->game_->getConfig().scrollSpeedMs = 5;
    suite->game_->getConfig().scrollLength = 10;
    suite->game_->getConfig().markerPosition = 50;  // way beyond scrollLength

    suite->game_->skipToState(suite->device_.pdn, 2);  // Gameplay
    suite->tick(1);

    auto& session = suite->game_->getSession();
    int failsBefore = session.fails;

    // Advance enough time for symbol to reach scrollLength (10 steps * 5ms = 50ms)
    suite->tickWithTime(20, 10);

    // Should have transitioned to Evaluate and counted a fail
    ASSERT_GT(session.fails, failsBefore);
}

// ============================================
// EVALUATE ROUTING TESTS
// ============================================

/*
 * Test: Evaluate routes to Show for next exploit (mid-sequence).
 */
void exploitSeqEvaluateRoutesToNextExploit(ExploitSequencerTestSuite* suite) {
    auto& session = suite->game_->getSession();
    auto& config = suite->game_->getConfig();

    // Set up mid-sequence: exploit 0 of exploitsPerSeq, sequence 0
    session.currentExploit = 0;
    session.currentSequence = 0;
    session.fails = 0;
    session.playerPressed = false;  // timeout = miss

    suite->game_->skipToState(suite->device_.pdn, 3);  // Evaluate
    suite->tick(2);

    // Should route to Show (next exploit)
    ASSERT_EQ(suite->game_->getCurrentState()->getStateId(), EXPLOIT_SHOW);
}

/*
 * Test: Evaluate advances sequence when last exploit in sequence completes.
 */
void exploitSeqEvaluateAdvancesSequence(ExploitSequencerTestSuite* suite) {
    auto& session = suite->game_->getSession();
    auto& config = suite->game_->getConfig();

    // Set up: last exploit in first sequence
    session.currentExploit = config.exploitsPerSeq - 1;
    session.currentSequence = 0;
    session.fails = 0;
    session.playerPressed = false;  // timeout = miss

    suite->game_->skipToState(suite->device_.pdn, 3);  // Evaluate
    suite->tick(2);

    // Sequence should have advanced
    ASSERT_EQ(session.currentSequence, 1);
    ASSERT_EQ(session.currentExploit, 0);
}

/*
 * Test: Evaluate routes to Win when all sequences are complete.
 */
void exploitSeqEvaluateRoutesToWin(ExploitSequencerTestSuite* suite) {
    auto& session = suite->game_->getSession();
    auto& config = suite->game_->getConfig();

    // Set up: last exploit of last sequence, with hit
    session.currentExploit = config.exploitsPerSeq - 1;
    session.currentSequence = config.sequences - 1;
    session.fails = 0;
    session.symbolPosition = config.markerPosition;  // perfect hit
    session.playerPressed = true;

    suite->game_->skipToState(suite->device_.pdn, 3);  // Evaluate
    suite->tick(2);

    ASSERT_EQ(suite->game_->getCurrentState()->getStateId(), EXPLOIT_WIN);
}

/*
 * Test: Evaluate routes to Lose when fails exceed allowed.
 */
void exploitSeqEvaluateRoutesToLose(ExploitSequencerTestSuite* suite) {
    auto& session = suite->game_->getSession();
    auto& config = suite->game_->getConfig();

    // Set fails to exactly at the limit, then trigger a miss
    session.fails = config.failsAllowed;
    session.playerPressed = false;  // timeout = miss, will push fails over limit

    suite->game_->skipToState(suite->device_.pdn, 3);  // Evaluate
    suite->tick(2);

    ASSERT_EQ(suite->game_->getCurrentState()->getStateId(), EXPLOIT_LOSE);
}

// ============================================
// WIN/LOSE OUTCOME TESTS
// ============================================

/*
 * Test: Win state sets outcome to WON with session score.
 */
void exploitSeqWinSetsOutcome(ExploitSequencerTestSuite* suite) {
    auto& session = suite->game_->getSession();
    session.score = 400;

    suite->game_->skipToState(suite->device_.pdn, 4);  // Win
    suite->tick(1);

    ASSERT_EQ(suite->game_->getOutcome().result, MiniGameResult::WON);
    ASSERT_EQ(suite->game_->getOutcome().score, 400);
}

/*
 * Test: Lose state sets outcome to LOST with session score.
 */
void exploitSeqLoseSetsOutcome(ExploitSequencerTestSuite* suite) {
    auto& session = suite->game_->getSession();
    session.score = 100;

    suite->game_->skipToState(suite->device_.pdn, 5);  // Lose
    suite->tick(1);

    ASSERT_EQ(suite->game_->getOutcome().result, MiniGameResult::LOST);
    ASSERT_EQ(suite->game_->getOutcome().score, 100);
}

// ============================================
// STANDALONE LOOP TEST
// ============================================

/*
 * Test: In standalone mode, Win loops back to Intro after timer.
 */
void exploitSeqStandaloneLoopsToIntro(ExploitSequencerTestSuite* suite) {
    suite->game_->skipToState(suite->device_.pdn, 4);  // Win
    suite->tick(1);

    ASSERT_EQ(suite->game_->getCurrentState()->getStateId(), EXPLOIT_WIN);

    // Advance past win timer (3s)
    suite->tickWithTime(35, 100);

    ASSERT_EQ(suite->game_->getCurrentState()->getStateId(), EXPLOIT_INTRO);
}

// ============================================
// STATE NAME TESTS
// ============================================

/*
 * Test: All 6 state names resolve correctly.
 */
void exploitSeqStateNamesResolve(ExploitSequencerTestSuite* suite) {
    ASSERT_STREQ(getExploitSequencerStateName(EXPLOIT_INTRO), "ExploitSeqIntro");
    ASSERT_STREQ(getExploitSequencerStateName(EXPLOIT_WIN), "ExploitSeqWin");
    ASSERT_STREQ(getExploitSequencerStateName(EXPLOIT_LOSE), "ExploitSeqLose");
    ASSERT_STREQ(getExploitSequencerStateName(EXPLOIT_SHOW), "ExploitSeqShow");
    ASSERT_STREQ(getExploitSequencerStateName(EXPLOIT_GAMEPLAY), "ExploitSeqGameplay");
    ASSERT_STREQ(getExploitSequencerStateName(EXPLOIT_EVALUATE), "ExploitSeqEvaluate");

    // Verify getStateName routes correctly
    ASSERT_STREQ(getStateName(EXPLOIT_INTRO), "ExploitSeqIntro");
    ASSERT_STREQ(getStateName(EXPLOIT_SHOW), "ExploitSeqShow");
    ASSERT_STREQ(getStateName(EXPLOIT_GAMEPLAY), "ExploitSeqGameplay");
    ASSERT_STREQ(getStateName(EXPLOIT_EVALUATE), "ExploitSeqEvaluate");
}

// ============================================
// MANAGED MODE TEST
// ============================================

/*
 * Test: FDN flow — GameType 5, KonamiButton B=4.
 * Launches Exploit Sequencer via FDN handshake, plays through to win,
 * and verifies return to FdnComplete.
 */
void exploitSeqManagedModeReturns(ExploitSequencerManagedTestSuite* suite) {
    suite->advanceToIdle();

    // Trigger FDN handshake for Exploit Sequencer (GameType 5, KonamiButton B=4)
    suite->player_.serialOutDriver->injectInput("*fdn:5:4\r");
    for (int i = 0; i < 3; i++) {
        SerialCableBroker::getInstance().transferData();
        suite->player_.pdn->loop();
    }
    ASSERT_EQ(suite->getPlayerStateId(), FDN_DETECTED);

    // Complete handshake
    suite->player_.serialOutDriver->injectInput("*fack\r");
    suite->tickWithTime(5, 100);

    // Should be in Exploit Sequencer Intro now
    auto* es = suite->getExploitSequencer();
    ASSERT_NE(es, nullptr);
    ASSERT_TRUE(es->getConfig().managedMode);

    // Advance past intro timer (2s)
    suite->tickWithTime(25, 100);

    // Should be in Show state now
    ASSERT_EQ(es->getCurrentState()->getStateId(), EXPLOIT_SHOW);

    // Advance past show timer (1.5s)
    suite->tickWithTime(20, 100);

    // Should be in Gameplay
    ASSERT_EQ(es->getCurrentState()->getStateId(), EXPLOIT_GAMEPLAY);

    // Configure for easy win: wide window, press at right time
    es->getConfig().timingWindow = 45;
    es->getConfig().exploitsPerSeq = 1;
    es->getConfig().sequences = 1;

    // Advance symbol to within window
    suite->tickWithTime(5, 50);

    // Press to hit
    suite->player_.primaryButtonDriver->execCallback(ButtonInteraction::CLICK);
    suite->tick(3);

    // Should route through Evaluate to Win
    // May need more ticks to transition through
    suite->tickWithTime(5, 100);

    ASSERT_EQ(es->getCurrentState()->getStateId(), EXPLOIT_WIN);
    ASSERT_EQ(es->getOutcome().result, MiniGameResult::WON);

    // Advance past win timer (3s) — should return to Quickdraw
    suite->tickWithTime(35, 100);

    ASSERT_EQ(suite->getPlayerStateId(), FDN_COMPLETE);
}

#endif // NATIVE_BUILD
