#pragma once

#ifdef NATIVE_BUILD

#include <gtest/gtest.h>
#include "cli/cli-device-full.hpp"
#include "cli/cli-serial-broker.hpp"
#include "cli/cli-http-server.hpp"
#include "game/exploit-sequencer/exploit-sequencer.hpp"
#include "game/exploit-sequencer/exploit-sequencer-states.hpp"
#include "game/minigame.hpp"
#include "device/device-types.hpp"
#include "utils/simple-timer.hpp"
#include <cstdint>

using namespace cli;

// ============================================
// EXPLOIT SEQUENCER TEST SUITE (standalone)
// ============================================

class ExploitSequencerTestSuite : public testing::Test {
public:
    void SetUp() override {
        // Reset all singleton state before each test to prevent pollution
        SerialCableBroker::resetInstance();
        MockHttpServer::resetInstance();
        SimpleTimer::resetClock();

        device_ = DeviceFactory::createGameDevice(0, "exploit-sequencer");
        SimpleTimer::setPlatformClock(device_.clockDriver);
        game_ = static_cast<ExploitSequencer*>(device_.game);
    }

    void TearDown() override {
        DeviceFactory::destroyDevice(device_);

        // Clean up singleton state after each test
        SerialCableBroker::resetInstance();
        MockHttpServer::resetInstance();
        SimpleTimer::resetClock();
    }

    void tick(int n = 1) {
        for (int i = 0; i < n; i++) {
            device_.pdn->loop();
        }
    }

    void tickWithTime(int n, int delayMs) {
        for (int i = 0; i < n; i++) {
            device_.clockDriver->advance(delayMs);
            device_.pdn->loop();
        }
    }

    DeviceInstance device_;
    ExploitSequencer* game_ = nullptr;
};

// ============================================
// EXPLOIT SEQUENCER MANAGED TEST SUITE (FDN)
// ============================================

class ExploitSequencerManagedTestSuite : public testing::Test {
public:
    void SetUp() override {
        player_ = DeviceFactory::createDevice(0, true);
        SimpleTimer::setPlatformClock(player_.clockDriver);
    }

    void TearDown() override {
        DeviceFactory::destroyDevice(player_);
    }

    void tick(int n = 1) {
        for (int i = 0; i < n; i++) {
            player_.pdn->loop();
        }
    }

    void tickWithTime(int n, int delayMs) {
        for (int i = 0; i < n; i++) {
            player_.clockDriver->advance(delayMs);
            player_.pdn->loop();
        }
    }

    void advanceToIdle() {
        player_.game->skipToState(player_.pdn, 6);
        player_.pdn->loop();
    }

    int getPlayerStateId() {
        return player_.game->getCurrentStateId();
    }

    ExploitSequencer* getExploitSequencer() {
        return static_cast<ExploitSequencer*>(
            player_.pdn->getApp(StateId(EXPLOIT_SEQUENCER_APP_ID)));
    }

    DeviceInstance player_;
};

// ============================================
// CONFIG PRESET TESTS
// ============================================

/*
 * Test: EASY config has rhythm game parameters.
 */
void exploitSeqEasyConfigPresets(ExploitSequencerTestSuite* suite) {
    ExploitSequencerConfig easy = makeExploitSequencerEasyConfig();
    ASSERT_EQ(easy.rounds, 4);
    ASSERT_EQ(easy.notesPerRound, 8);
    ASSERT_EQ(easy.noteSpeedMs, 50);
    ASSERT_EQ(easy.hitZoneWidthPx, 20);
    ASSERT_EQ(easy.lives, 3);
}

/*
 * Test: HARD config has rhythm game parameters.
 */
void exploitSeqHardConfigPresets(ExploitSequencerTestSuite* suite) {
    ExploitSequencerConfig hard = makeExploitSequencerHardConfig();
    ASSERT_EQ(hard.rounds, 4);
    ASSERT_EQ(hard.notesPerRound, 12);
    ASSERT_EQ(hard.noteSpeedMs, 30);
    ASSERT_EQ(hard.hitZoneWidthPx, 14);
    ASSERT_EQ(hard.lives, 3);
}

// ============================================
// INTRO TESTS
// ============================================

/*
 * Test: Intro resets a dirty session to clean state.
 */
void exploitSeqIntroResetsSession(ExploitSequencerTestSuite* suite) {
    // Dirty the session
    auto& session = suite->game_->getSession();
    session.score = 999;
    session.currentRound = 3;
    session.livesRemaining = 0;
    session.currentPattern.push_back(ExploitNote());

    // Skip to Intro (index 0) to trigger reset
    suite->game_->skipToState(suite->device_.pdn, 0);
    suite->tick(1);

    ASSERT_EQ(session.score, 0);
    ASSERT_EQ(session.currentRound, 0);
    ASSERT_EQ(session.livesRemaining, 3);
    ASSERT_TRUE(session.currentPattern.empty());
}

/*
 * Test: Intro transitions to Show after timer expires.
 */
void exploitSeqIntroTransitionsToShow(ExploitSequencerTestSuite* suite) {
    // Skip to intro to ensure clean state with clock set
    suite->game_->skipToState(suite->device_.pdn, 0);
    suite->tick(1);

    ASSERT_EQ(suite->game_->getCurrentStateId(), EXPLOIT_INTRO);

    // Advance past 2s intro timer
    suite->tickWithTime(30, 100);

    ASSERT_EQ(suite->game_->getCurrentStateId(), EXPLOIT_SHOW);
}

// ============================================
// STATE NAME TESTS
// ============================================

/*
 * Test: All 6 state names resolve correctly.
 */
void exploitSeqStateNamesResolve(ExploitSequencerTestSuite* suite) {
    ASSERT_STREQ(getExploitSequencerStateName(EXPLOIT_INTRO), "ExploitSeqIntro");
    ASSERT_STREQ(getExploitSequencerStateName(EXPLOIT_WIN), "ExploitSeqWin");
    ASSERT_STREQ(getExploitSequencerStateName(EXPLOIT_LOSE), "ExploitSeqLose");
    ASSERT_STREQ(getExploitSequencerStateName(EXPLOIT_SHOW), "ExploitSeqShow");
    ASSERT_STREQ(getExploitSequencerStateName(EXPLOIT_GAMEPLAY), "ExploitSeqGameplay");
    ASSERT_STREQ(getExploitSequencerStateName(EXPLOIT_EVALUATE), "ExploitSeqEvaluate");

    // Verify getStateName routes correctly
    ASSERT_STREQ(getStateName(EXPLOIT_INTRO), "ExploitSeqIntro");
    ASSERT_STREQ(getStateName(EXPLOIT_SHOW), "ExploitSeqShow");
    ASSERT_STREQ(getStateName(EXPLOIT_GAMEPLAY), "ExploitSeqGameplay");
    ASSERT_STREQ(getStateName(EXPLOIT_EVALUATE), "ExploitSeqEvaluate");
}

// NOTE: Most tests removed during Guitar Hero redesign (PR #TBD).
// The game mechanics changed from QTE timing to rhythm game with lanes/notes.
// Integration tests remain in comprehensive-integration-tests.hpp and
// e2e-game-suite-tests.hpp with updated API usage.

#endif // NATIVE_BUILD
