#include "game/exploit-sequencer/exploit-sequencer.hpp"
#include "game/exploit-sequencer/exploit-sequencer-states.hpp"
#include <cmath>

void ExploitSequencer::populateStateMap() {
    seedRng(config.rngSeed);

    ExploitSequencerIntro* intro = new ExploitSequencerIntro(this);
    ExploitSequencerShow* show = new ExploitSequencerShow(this);
    ExploitSequencerGameplay* gameplay = new ExploitSequencerGameplay(this);
    ExploitSequencerEvaluate* evaluate = new ExploitSequencerEvaluate(this);
    ExploitSequencerWin* win = new ExploitSequencerWin(this);
    ExploitSequencerLose* lose = new ExploitSequencerLose(this);

    // Intro -> Show
    intro->addTransition(
        new StateTransition(
            std::bind(&ExploitSequencerIntro::transitionToShow, intro),
            show));

    // Show -> Gameplay
    show->addTransition(
        new StateTransition(
            std::bind(&ExploitSequencerShow::transitionToGameplay, show),
            gameplay));

    // Gameplay -> Evaluate
    gameplay->addTransition(
        new StateTransition(
            std::bind(&ExploitSequencerGameplay::transitionToEvaluate, gameplay),
            evaluate));

    // Evaluate -> Show (next exploit)
    evaluate->addTransition(
        new StateTransition(
            std::bind(&ExploitSequencerEvaluate::transitionToShow, evaluate),
            show));

    // Evaluate -> Win (all sequences complete)
    evaluate->addTransition(
        new StateTransition(
            std::bind(&ExploitSequencerEvaluate::transitionToWin, evaluate),
            win));

    // Evaluate -> Lose (too many fails)
    evaluate->addTransition(
        new StateTransition(
            std::bind(&ExploitSequencerEvaluate::transitionToLose, evaluate),
            lose));

    // Standalone mode: win/lose loop back to intro for replay
    win->addTransition(
        new StateTransition(
            std::bind(&ExploitSequencerWin::transitionToIntro, win),
            intro));

    lose->addTransition(
        new StateTransition(
            std::bind(&ExploitSequencerLose::transitionToIntro, lose),
            intro));

    // Push order: intro(0), show(1), gameplay(2), evaluate(3), win(4), lose(5)
    stateMap.push_back(intro);
    stateMap.push_back(show);
    stateMap.push_back(gameplay);
    stateMap.push_back(evaluate);
    stateMap.push_back(win);
    stateMap.push_back(lose);
}

void ExploitSequencer::resetGame() {
    MiniGame::resetGame();
    session.reset();
}

std::vector<ExploitNote> ExploitSequencer::generatePattern(int round) {
    std::vector<ExploitNote> pattern;

    int noteCount = config.notesPerRound;
    int spacing = 128 / noteCount;  // distribute notes across screen width

    for (int i = 0; i < noteCount; i++) {
        // Decide if this is a dual-lane note
        bool isDual = (rand() % 1000) < (config.dualLaneChance * 1000);

        // Generate UP lane note
        ExploitNote upNote;
        upNote.lane = ExploitLane::UP;
        upNote.xPosition = 128 + (i * spacing);
        upNote.active = true;
        upNote.grade = ExploitNoteGrade::NONE;

        // Decide if it's a hold note
        bool isHold = (rand() % 1000) < (config.holdNoteChance * 1000);
        if (isHold) {
            upNote.type = ExploitNoteType::HOLD;
            // Calculate hold length based on speed and duration
            int speedMs = config.noteSpeedMs * pow(config.speedRampPerRound, round);
            upNote.holdLength = config.holdDurationMs / speedMs;
        } else {
            upNote.type = ExploitNoteType::PRESS;
            upNote.holdLength = 0;
        }

        pattern.push_back(upNote);

        // Generate DOWN lane note if dual
        if (isDual) {
            ExploitNote downNote = upNote;
            downNote.lane = ExploitLane::DOWN;
            pattern.push_back(downNote);
        } else {
            // Otherwise, randomly choose DOWN lane for this position
            if (rand() % 2 == 0) {
                pattern[pattern.size() - 1].lane = ExploitLane::DOWN;
            }
        }
    }

    return pattern;
}
